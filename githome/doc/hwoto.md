
< JSP 페이지의 구성요소 >
 1. 디렉티브
    - JSP 페이지에 대한 설정 정보를 지정
    - 디렉티브: page, taglib, include
    <%@ 디렉티브이름 속성1="값" 속성2="값" ... %> 
 2. 스크립트 요소
    - JSP에서 실시간으로 문서의 내용을 생성하기 위해 사용되는 것.
   A. 스크립트릿 : 자바 코드를 실행  <% ... %>
   B. 표현식 : 값 출력  <%= ... %>
   C. 선언부 : 자바 메소드를 만듬 <%! ... %>
 3. 기본 객체
    - JSP에서 웹 어플리케이션 프로그래밍에 제공하는 기본 객체
    - rquest, response, session, application, page
    - 요청 파라미터 읽어오기, 응답 결과 전송하기, 세션 처리하기, 웹어플리케이션 정보 읽어오기 등 기능 제공.
 4. 표현 언어
    - JSP의 스크립트 요소는 자바 문법을 그대로 사용할 수 있는 강력한 기능 제공.
    - 그러나, 자바 지식없다면 어려워.
    - 자바 몰라도 작업 가능하도록 JSP 페이지 내부에서 간단히 사용할 수 있는 스크립트 언어 제공.
 5. 정적인 데이터
 6. 표준 액션 태그
    - XML 태그와 같은 모양을 취함.
    - JSP 페이지에서 특별한 기능을 제공
    - <jsp:include> : 특정한 페이지의 실행 결과를 현재 위치에 포함시킬 때 사용.
 7. 커스텀 태그와 JSTL
   * 커스텀 태그
    - JSP를 확장시켜주는 기능
    - 태그 형태로 기능 제공
    - JSP 코드에서 중복되는 것을 모듈화에 사용
    - 또는, 스크립트 코드를 사용할 때의 소스코드의 복잡함을 없애기 위해 사용
   * JSTL
    - 커스텀 태그 중에서 자주 사용되는 것들을 표준화한 태그 라이브러리
    - if/else, for 구문 등을 커스텀 태그로 구현할 수 있게 해 줌.
    - 스크립트 코드보다 코드가 쉬워서 자바 언어 잘 몰라도 어느정도 논리적인 처리를 수행할 수 있음.
    
< 표현언어 EL >
 * 표현언어 ${name}
    - 값을 표현하는 데 사용되는 새로운 스크립트 언어
    - JSP 기본 문법을 보완하는 역할
    - 스크립트 요소 중의 하나인 표현식보다 간결하고 표현식 대신 많이 사용함.
    - JSP 2.0 부터 지원.
    - 장점: 표현식보다 간단한 방법으로 값 출력 가능.
    - 특징: JSP 스크립트 요소(스트립트릿, 표현식, 선언부)를 제외한 곳에서 사용 가능.
    - #{name} : JSP2.1에 추가됨. JSF(JavaServer Faces)에서 사용되던 표현 언어 구문.
      - 차이: ${name}은 곧 바로 값을 계산함. #{name}은 실제로 값이 사용될 때 계산함.
      - 실제로 값이 필요할 때 계산해서, Deferred Expression이라고 불림.
      - 그래서, Deferred Expression을 허용하는 태그의 속성에서만 사용 가능. ex) <c:out>
    - 제공하는 기능
        - JSP의 4가지 기본 객체가 제공하는 영역의 속성 사용
        - 집합 객체에 대한 접근 방법 제공
        - 수치 연산, 관계 연산, 논리 연산자 제공
        - 자바 클래스 메소드 호출 기능 제공
        - 표현 언어만의 기본 객체 제공

 * EL이 제공하는 기본 객체 (총 11개 중 몇개만 소개)
  - pageContext : JSP의 page 기본 객체와 동일
  - pageScope : pageContext 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체.
  - requestScope : request 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체.
  - sessionScope : session 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체.
  - applicationScope : application 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체.
  - param : 요청 파라미터의 <파라미터이름, 값> 매핑을 저장한 Map 객체.
  - cookie : <쿠키이름, Cookie> 매핑을 저장한 Map 객체.
   ex) requestScope.name, param.name
 * 특징
    - 값이 존재하지 않으면 아무 것도 출력하지 않음.
    - null 데이터 타입이 있음.
    - ${name}은 EL의 4개 영역을 차례대로 검색해서 속성이 존재하는지 확인한다.
      (page < request < session < application)
    - ${"10" + 1} == 11
    - 나눗셈 결과는 Double이다. 3/2 -> 1.5
    - 문자열/객체 비교연산 : compareTo() 사용 (== 가 자동 변환됨)
    - empty 연산자 : 검사할 객체가 텅 빈 객체인지를 검사
        - empty <값> 
        - true: 값이 null or "" or 길이가 0인 배열 or 빈 Map or 빈 Collection
    - 클래스 정적 메소드 호출하기
        1. 사용할 클래스 작성 : static 메소드만 가능!
        2. 함수를 정의한 TLD 파일 작성
        3. web.xml 파일에 TLD 내용 추가하기

< JSTL >
 * JSTL이란
    - 커스텀 태그 : 개발자가 직접 태그를 작성할 수 있는 기능 제공.
    - 많이 사용하는 커스텀 태그를 모아놓은 것
    - HTML와 비슷한 태그를 사용하여 보기 좋고, 이해하기 쉬운 코드를 작성하 수 있게 해 줌.
    - JSTL이 제공하는 태그의 종류
        1. 코어 : 접두어 c
            - 변수 지원, 흐름 제어, URL 처리
        2. XML : x
            - XML 코어, 흐름 제어, XML 변환
        3. 국제화 : fmt
            - 지역, 메시지 형식, 숫자/날짜 변환
        4. 데이터베이스 : sql
            - SQL
        5. 함수 : fn
            - Collection 처리, SQL 처리
    - 라이브러리 받기
        - 톰캣 7은 JSTL 1.2를 포함하고 있지 않음.
            -> WEB-INF/lib/jstl-1.2.jar 파일 복사
 * 코어 태그
    - taglib 디렉티브 추가 필요
    <%@ tablib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
    1. 변수 지원
        - set : JSP에서 사용될 변수를 설정
            <c:set var="변수명" value="값" [scope="영역"] />
            <c:set var="변수명" [scope="영역"]> 값 </c:set>
            - 영역 : page(기본), request, session, application
            <c:set target="자바빈 또는 Map" property="프로퍼티이름" value="값" />
        - remove: 설정한 변수를 제거
    2. 흐름 제어
        - if : 조건에 따라 내부 코드 수행
            <c:if test="조건"> ... </c:if>
             - test 속성: true or false를 리턴하는 조건문
        - choose : 다중 조건 처리 (switch + else if)
            <c:choose>
                <c:when test="조건1" >
                    ...
                </c:when>
                <c:when test="조건2" >
                    ...
                </c:when>
                <c:otherwise>
                    ...
                </c:otherwise>
            </c:choose>
        - forEach : 배열, Collection이나 Map의 각 항목 처리시 사용
            <c:forEach var="i" begin="1" end="10" step="2">
                ${i} 사용
            </c:forEach>
            <c:forEach var="i" items="${map}" >
                ${i.key} = ${i.value} <br>          // name = 최범균
            </c:forEach>
            <c:forEach var="변수" items="아이템" >
                ...
                <tr>
                    <td align="right" bgcolor="#ffffff">
                        ${변수사용}
                    </td>
                </tr>
                ...
            </c:forEach>
            <c:forEach var="item" items="<%= someItemList %>" varStatus="status">
                ${status.index + 1} 번째 항목 : ${item.name}
            </c:forEach>
             - varStatus : 루프 정보를 저장한 객체를 리턴함.
                - index : 루프 실행에서 현재 인덱스
                - count : 루프 실행 횟수
                - first : 현재 실행이 첫번째 실행인지
                - last : 현재 실행이 마지막 실행인지
                - current : Collection 중 현재 루프에서 사용할 객체
            
        - forTokens : 구분자로 분리된 각각의 토큰을 처리할 때 사용
            <c:forTokens var="color" items="red,green,blue" delims=",.">
                ${color}
            </c:forTokens>
    3. URL 처리
        - import : URL을 사용하여 다른 자원의 결과를 삽입
        - rediret : 지정한 경로로 리다이렉트한다.
        - url : URL을 재작성한다.
    4. 기타 태그
        - catch : 예외 처리에 사용
        - out : JspWriter에 내용을 알맞게 처리한 후 출력한다.
        


< 페이지 모듈화와 요청 흐름 제어 >
 * <jsp:include page="JSP 파일이름">
  - 다수의 웹 페이지들은 동일한 영역을 갖는다. (상단, 좌측메뉴, 중앙내용, 하단)
  - 다른 JSP로 흐름을 이동시켜 그 결과를 현재 위치에 포함시키는 방식.
  - 활용 : 화면의 레이아웃의 일부분을 모듈화할 때 주로 사용.
 * <%@ include file="포함할 파일이름" %>
  - 포함할 파일 내용을 현재 위치에 삽입한 후에 JSP파일을 자바 파일로 변환하고 컴파일하는 방식.
  - 보통 확장자 jspf 사용 - JSP Fragment(코드조각) 의미.
  - 코드 조각 자동 포함 기능(JSP 2.0부터 지원) : <jsp-property-group>으로 상단,하단 추가 가능.
  - 활용
    - 모든 JSP 페이지에서 사용되는 변수 지정
    - 저작권 표시와 같은 간단하면서도 모든 페이지에서 중복되는 문장
 * <jsp:forward page="page name">
  - 다른 JSP로 흐름을 이동시키고, 결과 화면을 웹브라우저로 전달.
  - 다른 JSP로 이동하기 전에 출력버퍼가 비워진다.
 * page 속성의 경로
  - 절대경로 : 거의 대부분 사용.
  - 상대경로 : 같은 디렉토리, 하위 디렉토리 파일 이용시.

< 쿠키 >
 * 일반적인 쿠키 사용 팁
  - 웹 어플리케이션에 포함된 다수의 JSP/서블릿에서 공통으로 사용하는 경우가 많아 "/"로 지정.
  - 아이디 기억하기 기능의 구현방법
    1. 사용자가 로그인에 성공하면
    2. 아이디를 값으로 저장하고 있는 쿠키의 유효 시간을 "한달" 정도로 잡아 생성한다.
    3. 로그인 상태 정보까지 동일한 방식으로 쿠키에 저장하면 자동 로그인 기능 가능.

 * 쿠키의 제한사항
    1. 도메인 별 쿠키 생성 가능한 개수
        - IE old : 20개
        - IE 7, IE 8 : 50개
        - Firefox : 50개
        - Safari/Webkit : 제한 없음, 오히려 서버에서 헤더 크기 제한이 넘어가서 문제 발생.
    2. 쿠키가 꽉 찬 경우
        - IE : 가장 오래된 쿠키를 삭제하고 새로 추가.
        - Firefox : 랜덤하게 정해서 삭제 후 새로 추가.
    3. 쿠키의 크기(name, value, = 기호까지 포함)
        - Firefox, Safari : 4097 bytes
        - IE : 4095
    
 * 쿠키를 사용한 로그인 유지
  1. 로그인을 하면 관련 쿠키를 생성한다.
  2. 관련 쿠키가 존재하면 로그인한 상태라고 판단한다.
  3. 로그아웃을 하면 관련 쿠키를 삭제한다.

< 세션 >
 * 일반적인 팁
  - 세션은 웹 브라우저마다 따로 존재한다. (웹브라우저와 1대 1 정보 저장에 좋음)
  - 웹서버에 데이터 보관 장소
  - session 기본 객체를 통해 세션 사용 가능.
  - 세션에 별도 속성을 사용해서 연관 정보를 저장할 때는 클래스를 사용하는 걸 추천함.
 * 쿠키 대신 세션을 사용하는 이유
  - 세션이 쿠키보다 보안에서 앞선다.
  - 웹 브라우저가 쿠키를 지원하지 않거나 쿠키를 막은 경우도 세션을 사용할 수 있음.
 * 세션 유효기간의 필요성
  - 자리 비움에 따른 정보 누설을 최소화시킬 수 있음.
  - session.setMaxInactiveInteval(60 * 60) // seconds
 * 세션을 사용한 인증 정보 유지
    1. 로그인에 성공하면 session 기본 객체의 특정 속성에 데이터를 기록한다.
    2. 이후로 session 기본 객체의 특정 속성이 존재하면 로그인한 것으로 간주한다.
    3. 로그아웃 할 경우 session.invalide() 메소드를 호출하여 세션을 종료한다.

< 로그인 처리 >
 -  histroy.go(-1) : 이전 페이지로 이동. history.back(). 입력 양식이 사라지지 않고 유지됨.
 - 실제 로그인 성공시 생성되는 쿠키는 ID값을 암호해서 보관한다.(보안을 위해)
 
< 웹 어플리케이션의 구성 >
 * MVC 프레임워크
    - 사용자의 요청을 Service에 전달하고 Service의 실행결과를 JSP와 같은 뷰에 전달한다.
 * Service 클래스
    - 사용자의 요청을 처리하는 기능을 제공
    - 기능을 제공하기 위한 로직을 구현하고 있다.
    - DAO를 통해서 DB 연동을 처리한다.
 * DAO 클래스
    - DB와 관련된 CRUD 작업을 처리.
 * JSP(뷰)
    - Service가 실행한 결과를 화면에 출력해 준다.
    - Service가 기능을 수행하는 데 필요한 데이터를 전달한다.
    
< DAO >
 - Data Access Object
 - 데이터를 접근할 때 사용되는 객체를 위한 클래스를 의미함.
 - 일반적으로 한 개의 DB 테이블 당 한 개의 DAO 클래스를 작성한다.
 * DAO에서 Connection에 접근하는 방식
    - DAO 클래스의 메소드에서 직접 Connection을 생성
    - DAO 객체를 생성할 때 생성자로서 Connection을 전달받기 (이게 최선?)
    - DAO 클래스의 메소드 파라미터로 Connection을 전달받기
 * 간단한 close(), rollback() 처리코드를 위한 JdbcUtil
 * DB에 따라서 DAO 객체를 제공하는 DaoProvier

< 서비스 클래스 >
 - 사용자의 요청을 처리하기 위한 기능을 제공
 - 주로 DAO를 통해서 데이터에 접근하고, 기능을 수행하는데 필요한 로직을 수행한다.
 - 한 개의 서비스 클래스는 한 개의 기능을 제공하는 것이 구현/유지보수에 좋다.
 - ex) 게시글 목록 제공, 게시글 쓰기, 회원 등록, 회원 정보 수정
 - 서비스 클래스가 제공하는 메소드는 내부적으로 DB 처리 실패와 같은 예외가 발생한 경우,
  서비스에 알맞은 예외를 생성해서 발생시켜주는 것이 좋다.
 - 서비스 클래스의 메소드는 기능을 올바르게 실행하였는지 여부를 확인할 수 있도록,
  내부적으로 문제가 발생하면 관련된 예외를 발생시키도록 구현해주어야 한다.
 - 서비스 클래스는 논리적으로 잘못된 경우에도 예외를 발생시켜야 한다.
    ex) 존재하지 않는 게시글 삭제를 요청하는 경우 -> 게시글이 존재하지 않음을 알려줘야 함.
 - 싱글톤 패턴 적용
    : 특정 클래스의 객체가 단 한 개만 존재하도록 제약하는 구현 패턴.
        1. 유일한 객체를 정적 필드에 저장
            private static xxx instance = new xxx();
        2. 유일한 객체에 접근할 수 있는 정적 메소드 정의
            public static xxx getInstance() { return instance; }
        3. 생성자를 private로 설정해서 외부에서 접근하지 못함
            private xxx() {}
            
 * 게시글 조회 기능
    1. DAO의 select() 메소드를 이용해서 테이블로부터 데이터를 읽어온다.
      A. 데이터가 존재하지 않을 경우 예외를 발생한다.
      B. 데이터가 존재할 경우 데이터 값을 갖는 Article 객체를 리턴한다.
    2. Article 객체의 조회수 값을 1 증가시킨다.
    3. DAO의 update() 메소드를 이용해서 변경된 조회수 값을 테이블에 반영한다.
    
  